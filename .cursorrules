# Cursor Rules for Visa Bulletin Parser

## üö® Critical Rules

### Rule: Always Use Bazel for Testing and Running
**NEVER run Python or pytest directly. ALWAYS use Bazel.**

**‚úÖ GOOD:**
```bash
bazel test //tests:test_extractor
bazel run //:refresh_data
bazel test //tests:test_parser //tests:test_extractor //tests:test_integration
```

**‚ùå BAD:**
```bash
python refresh_data.py                    # Use: bazel run //:refresh_data
pytest tests/                             # Use: bazel test //tests:...
python -m unittest discover              # Use: bazel test //tests:...
source ~/visa-bulletin-venv/bin/activate # Not needed with Bazel
```

**Rationale:**
- Hermetic builds (reproducible)
- Intelligent caching (faster)
- Consistent with pre-commit hook
- Single source of truth for dependencies

### Rule: Only Commit When Explicitly Asked
**NEVER auto-commit changes. Only commit when user explicitly requests it.**

**User must explicitly say:**
- "commit these changes"
- "make a commit"
- "commit this"
- Or use explicit phrasing requesting a commit

**Do NOT commit when:**
- Finishing a task
- Fixing bugs
- Making changes
- User says "looks good" or "thanks"

**Rationale:**
- User controls git history
- Prevents premature commits
- Allows review before committing

## Bazel Build System

### Rule: One Bazel Target Per File
Always create one `py_library` or `py_binary` target per Python file unless it's impossible due to circular dependencies.

**Good:**
```python
py_library(
    name = "bulletint_parser",
    srcs = ["bulletint_parser.py"],
    deps = [":table"],
)

py_library(
    name = "table",
    srcs = ["table.py"],
)
```

**Bad:**
```python
py_library(
    name = "lib",
    srcs = [
        "bulletint_parser.py",
        "table.py",
        "other.py",
    ],
)
```

**Rationale:**
- Better granularity for incremental builds
- Clear dependency tracking
- Faster compilation (only rebuild changed modules)
- Easier to understand build graph

### Exceptions
Only bundle multiple files into one target when:
- Circular dependencies exist between modules
- Files are tightly coupled and always used together
- Performance measurements show significant benefit

## Python Code Style

- Follow PEP 8
- **Python 3.11+**: Use modern type hints (no `typing` imports for basic types)
  - ‚úÖ `list[str]`, `dict[str, int]`, `tuple[int, str]`
  - ‚úÖ `str | None` (not `Optional[str]`)
  - ‚úÖ `int | str` (not `Union[int, str]`)
  - ‚ùå `from typing import List, Dict, Tuple, Optional, Union`
- Add docstrings to public functions and classes
- Keep functions focused and single-purpose

### Rule: Use Django TextChoices for Database Enums

**Always use Django TextChoices for categorical database fields.**

**Why TextChoices?**
- ‚úÖ Type-safe enums in Python code
- ‚úÖ Readable strings in database ('china' not '1')
- ‚úÖ Human-readable labels for admin/UI
- ‚úÖ IDE autocomplete on enum values
- ‚úÖ Database constraints automatically

**Pattern:**

```python
from django.db import models

class Country(models.TextChoices):
    """Country for visa chargeability"""
    CHINA = "china", "China (mainland born)"  # (value, label)
    INDIA = "india", "India"
    
    @classmethod
    def from_header(cls, header: str):
        """Custom parsing method"""
        mappings = {
            'CHINA-mainland born': cls.CHINA,
            'INDIA': cls.INDIA,
        }
        return mappings.get(header)

# In models
class VisaCutoffDate(models.Model):
    country = models.CharField(
        max_length=50,
        choices=Country.choices  # Django constraint
    )
```

**Usage:**

```python
# ‚úÖ Queries with enums (type-safe)
records = VisaCutoffDate.objects.filter(country=Country.CHINA)

# ‚úÖ Access enum instance from record
record = VisaCutoffDate.objects.first()
print(record.country)        # 'china' (string value)
print(record.get_country_display())  # 'China (mainland born)' (label)

# ‚úÖ Tests
assert result['country'] == Country.CHINA.value

# ‚úÖ Data creation
VisaCutoffDate.objects.create(country=Country.CHINA)
```

**Benefits:**
- Type safety and IDE autocomplete
- Readable database queries (SELECT shows 'china')
- Single source of truth
- Automatic database constraints
- Admin UI shows human-readable labels

## Testing

### Test Quality Rules

**Do NOT write trivial tests** that only check if code exists:
- ‚ùå BAD: Testing if an enum has a specific value (e.g., `assertEqual(MyEnum.VALUE, "value")`)
- ‚ùå BAD: Testing if a class exists or can be imported
- ‚ùå BAD: Testing simple getters/setters with no logic
- ‚ùå BAD: Testing that a constant equals itself

**DO write meaningful behavioral tests**:
- ‚úÖ GOOD: Testing business logic and transformations
- ‚úÖ GOOD: Testing edge cases and error handling
- ‚úÖ GOOD: Testing integration between components
- ‚úÖ GOOD: Testing data validation and constraints
- ‚úÖ GOOD: Testing complex parsing or extraction logic

**Example:**
```python
# ‚ùå Trivial - just checks if value exists
def test_has_value(self):
    self.assertEqual(MyEnum.FOO.value, "foo")

# ‚úÖ Meaningful - tests behavior
def test_parse_table_header_to_country_enum(self):
    self.assertEqual(parse_country("CHINA-mainland born"), Country.CHINA)
    self.assertEqual(parse_country("All Chargeability Areas"), Country.ALL)
```

### Test Requirements

- All new features must include meaningful behavioral tests
- **ALWAYS use Bazel to run tests**: `bazel test //tests:test_name`
- **NEVER use pytest or python directly** (see Critical Rules above)
- Run tests before committing (pre-commit hook handles this)
- Aim for meaningful test coverage, not just high percentages
- Each test should verify actual behavior, not just existence

## Documentation

- Update README.md for user-facing changes
- Update CONTRIBUTING.md for developer workflow changes
- Update BAZEL.md for build system changes
- Keep inline code comments focused on "why" not "what"

## Git Workflow

- **ONLY commit when user explicitly requests it** (see Critical Rules above)
- Write clear, descriptive commit messages
- Tests run automatically via pre-commit hook
- Don't bypass hooks unless absolutely necessary
- Keep commits focused and atomic

## Dependencies

- Add new dependencies to requirements.txt
- Use pinned versions for reproducibility
- Document why each dependency is needed

