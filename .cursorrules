# Cursor Rules for Visa Bulletin Parser

## Bazel Build System

### Rule: One Bazel Target Per File
Always create one `py_library` or `py_binary` target per Python file unless it's impossible due to circular dependencies.

**Good:**
```python
py_library(
    name = "bulletint_parser",
    srcs = ["bulletint_parser.py"],
    deps = [":table"],
)

py_library(
    name = "table",
    srcs = ["table.py"],
)
```

**Bad:**
```python
py_library(
    name = "lib",
    srcs = [
        "bulletint_parser.py",
        "table.py",
        "other.py",
    ],
)
```

**Rationale:**
- Better granularity for incremental builds
- Clear dependency tracking
- Faster compilation (only rebuild changed modules)
- Easier to understand build graph

### Exceptions
Only bundle multiple files into one target when:
- Circular dependencies exist between modules
- Files are tightly coupled and always used together
- Performance measurements show significant benefit

## Python Code Style

- Follow PEP 8
- Use type hints where appropriate
- Add docstrings to public functions and classes
- Keep functions focused and single-purpose

### Rule: Use Enums, Not Hardcoded Strings

**Always use enum values instead of hardcoded strings for categorical data.**

**Bad:**
```python
if country == 'CHINA':  # Hardcoded string
    ...

data = {
    'visa_category': 'FAMILY_SPONSORED',  # Hardcoded
    'country': 'ALL',  # Hardcoded
}
```

**Good:**
```python
if country == Country.CHINA.value:  # Enum value
    ...

data = {
    'visa_category': VisaCategory.FAMILY_SPONSORED.value,  # Enum value
    'country': Country.ALL.value,  # Enum value
}
```

**For mapping/parsing, add class methods to the enum itself:**

```python
class Country(Enum):
    ALL = "all"
    CHINA = "china"
    
    @classmethod
    def from_header(cls, header: str):
        """Parse country from table header"""
        mappings = {
            'All Chargeability Areas': cls.ALL,
            'CHINA-mainland born': cls.CHINA,
        }
        return mappings.get(header)
```

**In tests and queries, always use enum values:**

```python
# Bad: Hardcoded strings in tests
self.assertEqual(result['country'], 'china')
record = Model.objects.filter(country='all').first()

# Good: Use enum values
self.assertEqual(result['country'], Country.CHINA.value)
record = Model.objects.filter(country=Country.ALL.value).first()
```

**Benefits:**
- Type safety and IDE autocomplete
- Single source of truth
- Easy refactoring (rename enum, all usages update)
- Clear intent and compile-time checks
- Tests fail if enum values change

## Testing

### Test Quality Rules

**Do NOT write trivial tests** that only check if code exists:
- ❌ BAD: Testing if an enum has a specific value (e.g., `assertEqual(MyEnum.VALUE, "value")`)
- ❌ BAD: Testing if a class exists or can be imported
- ❌ BAD: Testing simple getters/setters with no logic
- ❌ BAD: Testing that a constant equals itself

**DO write meaningful behavioral tests**:
- ✅ GOOD: Testing business logic and transformations
- ✅ GOOD: Testing edge cases and error handling
- ✅ GOOD: Testing integration between components
- ✅ GOOD: Testing data validation and constraints
- ✅ GOOD: Testing complex parsing or extraction logic

**Example:**
```python
# ❌ Trivial - just checks if value exists
def test_has_value(self):
    self.assertEqual(MyEnum.FOO.value, "foo")

# ✅ Meaningful - tests behavior
def test_parse_table_header_to_country_enum(self):
    self.assertEqual(parse_country("CHINA-mainland born"), Country.CHINA)
    self.assertEqual(parse_country("All Chargeability Areas"), Country.ALL)
```

### Test Requirements

- All new features must include meaningful behavioral tests
- Tests should use Bazel: `bazel test //tests:...`
- Run tests before committing (pre-commit hook handles this)
- Aim for meaningful test coverage, not just high percentages
- Each test should verify actual behavior, not just existence

## Documentation

- Update README.md for user-facing changes
- Update CONTRIBUTING.md for developer workflow changes
- Update BAZEL.md for build system changes
- Keep inline code comments focused on "why" not "what"

## Git Workflow

- Write clear, descriptive commit messages
- Tests run automatically via pre-commit hook
- Don't bypass hooks unless absolutely necessary
- Keep commits focused and atomic

## Dependencies

- Add new dependencies to requirements.txt
- Use pinned versions for reproducibility
- Document why each dependency is needed

